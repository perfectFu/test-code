## 大O表示法

- 大O表示法指出最糟糕的情况下的运行时间
- 算法运行时间并不是以秒为单位
- 算法的运行时间是从其增速的角度度量的
- 算法运行时间用大O表示法

**常见的大O运行时间**

- O(log(n))，也叫对数时间，这样的算法包括二分查找
- O(n)，也叫线性时间，这样的算法包括简单查找
- O(n * log(n))，这样的算法包括快速排序，一种速度较快的排序算法
- O(n²)，这样的算法包括选择排序、冒泡排序，一种速度较慢的排序算法
- O(n!)，这样的算法包括 旅行商解决方案，一种非常慢的算法



## 二分查找

- 二分查找的速度比简单查找快得多
- O(log(n))比O(n)快，需要搜索的元素越多，前者比后者快得越多

````js
function binarySearch(arr, guess) {
    let low = 0
    let high = arr.length - 1
    let mid
    while(low <= high) {
        mid = Math.floor((low + high) / 2)
        if(arr[mid] === guess) {
            return mid
        } else if (arr[mid] < guess) {
            low = mid + 1
        } else {
            high = mid - 1
        }
    }
    return null
}
````



## 选择排序

时间复杂度O(n²)

- 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
- 在从剩余未排序元素中寻找最小（大）元素，然后放到已排序序列末尾
- 重复第二步，直到所有元素都排序完毕

````js
function selectSort(arr) {
	for (let i = 0; i < arr.length; i++) {
		// 找出最小数索引
		let min = i;
		for (let j = i + 1; j < arr.length; j++) {
			if (arr[j] < arr[min]) {
				min = j;
			}
		}
		// 将min存放到数组起始位置
		[arr[i], arr[min]] = [arr[min], arr[i]];
	}
	return arr;
}
````



## 冒泡排序

时间复杂度O(n²)

- 比较相邻的元素，如果第一个比第二个大就交换他们
- 对每一对相邻元素做同样工作，从开始的第一对到结束的最后一对，最后的元素会是最大数
- 针对所有元素重复以上步骤，除了最后一个
- 持续每次对越来越少的元素重复以上步骤，直到没有任何一对数字需要比较

````js
function bubbleSort(arr) {
	for (let i = 0; i < arr.length - 1; i++) {
		for (let j = 0; j < arr.length - i - 1; j++) {
			if (arr[j] > arr[j + 1]) {
				[arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
			}
		}
	}
	return arr;
}
````

